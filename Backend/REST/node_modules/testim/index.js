"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.describeOnly = exports.describeSkip = exports.only = exports.skip = exports.afterEach = exports.after = exports.beforeEach = exports.before = exports.describe = exports.test = exports.it = exports.screenshot = exports.waitForText = exports.waitForNoElement = exports.waitForElement = exports.resize = exports.waitForCode = exports.submit = exports.scrollToPosition = exports.drag = exports.dragAndDrop = exports.sendCharacter = exports.selectOption = exports.radio = exports.checkbox = exports.exists = exports.hover = exports.getCookie = exports.setCookie = exports.go = exports.cliAction = exports.evaluate = exports.type = exports.scrollToElement = exports.text = exports.url = exports.title = exports.refresh = exports.dropFile = exports.inputFile = exports.html = exports.getTestimInbox = exports.generateTestimEmail = exports.generateRandomValue = exports.downloadFile = exports.apiCall = exports.sleep = exports.dblclick = exports.click = exports.GeneratedValueTypes = void 0;
exports.withContext = exports.fromSelector = exports.l = exports.Locator = void 0;
/**
 * Happens when you call a test from node directly (node myFile.js) instead of through the Testim CLI (testim run myFile.js)
 */
var StubError = /** @class */ (function (_super) {
    __extends(StubError, _super);
    function StubError(name) {
        return _super.call(this, "Error calling ".concat(name, " stub. Codim needs to run through the Testim CLI")) || this;
    }
    return StubError;
}(Error));
/**
 * Represents the Testim Dev Kit step locator.
 * @see https://help.testim.io/docs/working-with-locators
 */
var TDKStepLocator = /** @class */ (function () {
    function TDKStepLocator() {
    }
    TDKStepLocator.prototype.find = function (selector) {
        throw new StubError('TDKStepLocator.find');
    };
    TDKStepLocator.prototype.nthChild = function (index) {
        throw new StubError('TDKStepLocator.nthChild');
    };
    TDKStepLocator.prototype.childWithText = function (text) {
        throw new StubError('TDKStepLocator.childWithText');
    };
    /**
     * Sets the locator confidence threshold
     * @param threshold the locator conidence score
     */
    TDKStepLocator.prototype.withConfidence = function (threshold) {
        throw new StubError('TDKStepLocator.withThreshold');
    };
    return TDKStepLocator;
}());
/**
 * Represents the return value from a getCookie or setCookie call.
 * @see https://help.testim.io/docs/get-cookie
 */
var CookieData = /** @class */ (function () {
    function CookieData() {
        this.httpOnly = true;
        this.secure = false;
    }
    return CookieData;
}());
var GeneratedValueTypes;
(function (GeneratedValueTypes) {
    GeneratedValueTypes["LettersOnly"] = "Letters Only";
    GeneratedValueTypes["NumbersOnly"] = "Numbers Only";
    GeneratedValueTypes["Mixed"] = "Mixed";
})(GeneratedValueTypes = exports.GeneratedValueTypes || (exports.GeneratedValueTypes = {}));
/**
 * Clicks the given element on the screen, clicks on the element in its center by default.
 * @see https://help.testim.io/docs/click
 */
function click(selector, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('click');
    }); });
}
exports.click = click;
/**
 * Clicks the given element on the screen, clicks on the element in its center by default.
 * @see https://help.testim.io/docs/dblclick
 */
function dblclick(selector, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('dblclick');
    }); });
}
exports.dblclick = dblclick;
/**
 * Sleeps a specified duration. Basically the same as
 * const sleep = require('util').promisify(setTimeout);
 * Except that it adds a sleep step to the UI
 * @param ms milliseconds to sleep
 */
function sleep(ms) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('sleep');
    }); });
}
exports.sleep = sleep;
/**
 * Api call
 */
function apiCall(url, options) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('apiCall');
    }); });
}
exports.apiCall = apiCall;
/**
 * Get latest download item work only in Chrome extension mode
 */
function downloadFile() {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('downloadFile');
    }); });
}
exports.downloadFile = downloadFile;
/**
 * Generate random value letters/numbers/mixed
 */
function generateRandomValue(generatedLength, valueType, prefixValue) {
    if (generatedLength === void 0) { generatedLength = 12; }
    if (valueType === void 0) { valueType = GeneratedValueTypes.Mixed; }
    if (prefixValue === void 0) { prefixValue = ''; }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('generateRandomValue');
    }); });
}
exports.generateRandomValue = generateRandomValue;
/**
 * Generate Testim random email - PRO feature
 */
function generateTestimEmail() {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('generateTestimEmail');
    }); });
}
exports.generateTestimEmail = generateTestimEmail;
/**
 * Get email messages from Testim email inbox - PRO feature
 */
function getTestimInbox(emailAddress) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('getTestimInbox');
    }); });
}
exports.getTestimInbox = getTestimInbox;
/**
 * Get document element outer html
 */
function html() {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('html');
    }); });
}
exports.html = html;
/**
 * This method used to simulate upload file on <input type="file">
 */
function inputFile(selector, inputFileUrls) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('inputFile');
    }); });
}
exports.inputFile = inputFile;
/**
 * This method used to simulate drop file on drop zone
 */
function dropFile(selector, inputFileUrls) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('dropFile');
    }); });
}
exports.dropFile = dropFile;
/**
 * Refresh current page
 */
function refresh() {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('refresh');
    }); });
}
exports.refresh = refresh;
/**
 * Get current page title
 */
function title() {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('title');
    }); });
}
exports.title = title;
/**
 * Get current page url
 */
function url() {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('url');
    }); });
}
exports.url = url;
/**
 * This method is used to extract an element's text content.
 * @see https://help.testim.io/docs/text
 */
function text(selector) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('text');
    }); });
}
exports.text = text;
/**
 * Scroll to a given element on the screen.
 * @see https://help.testim.io/docs/scroll-to-element
 */
function scrollToElement(selector, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('scrollToElement');
    }); });
}
exports.scrollToElement = scrollToElement;
/**
 * This method is used to set an element's text content. If the element already has text content it overrides it.
 * @see https://help.testim.io/docs/type
 */
function type(selector, textValue) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('type');
    }); });
}
exports.type = type;
/**
 * This method is used to run custom JavaScript in the browser application page. This is useful as an escape hatch and in order to implement interactions that are not available out of the box with Testim or in order to interact with the page JavaScript.
 * @see https://help.testim.io/docs/evaluate
 */
function evaluate(fn) {
    var parameters = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        parameters[_i - 1] = arguments[_i];
    }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('evaluate');
    }); });
}
exports.evaluate = evaluate;
/**
 * This method is used to execute an arbitrary command that runs in Node.js from within the test
 * @see https://help.testim.io/docs/cli-action
 */
function cliAction(fn) {
    var parameters = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        parameters[_i - 1] = arguments[_i];
    }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('cliAction');
    }); });
}
exports.cliAction = cliAction;
/**
 * The go command navigates to a given web page in the controlled browser.
 * @see https://help.testim.io/docs/go
 */
function go(url) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('go');
    }); });
}
exports.go = go;
/**
 * Sets a cookie on a given page.
 * @see https://help.testim.io/docs/set-cookie
 */
function setCookie(cookieData) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('setCookie');
    }); });
}
exports.setCookie = setCookie;
/**
 * Gets a cookie by a specific name.
 * @see https://help.testim.io/docs/get-cookie
 */
function getCookie(name) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('getCookie');
    }); });
}
exports.getCookie = getCookie;
/**
 * Hovers over the given element on the screen, on the element center by default.
 * @see https://help.testim.io/docs/hover
 */
function hover(selector, options) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('hover');
    }); });
}
exports.hover = hover;
/**
 * This method checks that an element matching the given selector exists on the page
 * @see https://help.testim.io/docs/exists
 */
function exists(selector) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('exists');
    }); });
}
exports.exists = exists;
/**
 * This method is used to check if a checkbox element is checked or not.
 * @see https://help.testim.io/docs/checkbox
 */
function checkbox(selector) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('checkbox');
    }); });
}
exports.checkbox = checkbox;
/**
 * This method is used to check if a radio element is checked or not.
 * @see https://help.testim.io/docs/radio
 */
function radio(selector) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('radio');
    }); });
}
exports.radio = radio;
/**
 * This method selects a given <option> element from an HTML <select> element.
 * @see https://help.testim.io/docs/select
 */
function selectOption(selector) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('selectOption');
    }); });
}
exports.selectOption = selectOption;
/**
 * Send a given key to the browser (for example tab).
 * @see https://help.testim.io/docs/send-character
 */
function sendCharacter(selector, keyCode) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('sendCharacter');
    }); });
}
exports.sendCharacter = sendCharacter;
/**
 * Drags and drops on the given element onto another element on the page using HTML5 drag and drop events.
 * @see https://help.testim.io/docs/drag-and-drop
 */
function dragAndDrop(sourceSelector, targetSelector) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('dragAndDrop');
    }); });
}
exports.dragAndDrop = dragAndDrop;
/**
 * Dragged the given element alongside the given x/y path.
 * @see https://help.testim.io/docs/drag
 */
function drag(selector, dragPath) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('drag');
    }); });
}
exports.drag = drag;
/**
 * https://help.testim.io/docs/scroll-to-position
 * @see https://help.testim.io/docs/scroll-to-position
 */
function scrollToPosition(x, y, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('scrollToPosition');
    }); });
}
exports.scrollToPosition = scrollToPosition;
/**
 * This method submits the given form element.
 * @see https://help.testim.io/docs/submit
 */
function submit(selector) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('submit');
    }); });
}
exports.submit = submit;
/**
 * This method polls the page every 100 (default ms) until a passed JavaScript value is true (well, truthy).
 * @see https://help.testim.io/docs/wait-for-code
 */
function waitForCode(fn, options) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('waitForCode');
    }); });
}
exports.waitForCode = waitForCode;
/**
 * Waits for an element to exist on the screen and be visible.
 * @see https://help.testim.io/docs/resize
 */
function resize(options) {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('resize');
    }); });
}
exports.resize = resize;
/**
 * Waits for an element to exist on the screen.
 * @see https://help.testim.io/docs/wait-for-element
 */
function waitForElement(selector, options) {
    if (options === void 0) { options = { checkVisibility: true }; }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('waitForElement');
    }); });
}
exports.waitForElement = waitForElement;
/**
 * Waits for an element to exist on the screen.
 * @see https://help.testim.io/docs/wait-for-element
 */
function waitForNoElement(selector, options) {
    if (options === void 0) { options = { checkVisibility: true }; }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('waitForNoElement');
    }); });
}
exports.waitForNoElement = waitForNoElement;
/**
 * Waits for an element to exist on the screen and its text equal to expected value.
 * @see https://help.testim.io/docs/wait-for-text
 */
function waitForText(selector, expectedValue, options) {
    if (options === void 0) { options = { checkVisibility: true }; }
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        throw new StubError('waitForText');
    }); });
}
exports.waitForText = waitForText;
exports.screenshot = {
    /**
     * Takes a screenshot of the whole screen
     */
    viewport: function viewport() {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            throw new StubError('screenshotViewport');
        }); });
    },
    /**
     * Takes a screenshot of the whole page by scrolling down and taking screenshots of the different parts and stitching them together
     */
    stitch: function stitch() {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            throw new StubError('screenshotStitch');
        }); });
    },
    /**
     * Takes a screenshot of a specific element
     */
    element: function element(selector) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            throw new StubError('screenshotElement');
        }); });
    }
};
/**
 * Defines a test to run.
 * @see https://help.testim.io/docs/getting-started
 */
function it(name, fn) { throw new StubError('it'); }
exports.it = it;
/**
 * Defines a test to run.
 * @see https://help.testim.io/docs/getting-started
 */
function test(name, fn) { throw new StubError('test'); }
exports.test = test;
/**
 * Defines a test suite to run.
 * @see https://help.testim.io/docs/getting-started
 */
function describe(name, fn) { throw new StubError('describe'); }
exports.describe = describe;
/**
 * Defines a piece of code to run before all tests in this file.
 * @see https://help.testim.io/docs/getting-started
 */
function before(fn) { throw new StubError('before'); }
exports.before = before;
/**
 * Defines a piece of code to run before each test in this file.
 * @see https://help.testim.io/docs/getting-started
 */
function beforeEach(fn) { throw new StubError('beforeEach'); }
exports.beforeEach = beforeEach;
/**
 * Defines a piece of code to run after  all tests in this file.
 * @see https://help.testim.io/docs/getting-started
 */
function after(fn) { throw new StubError('after'); }
exports.after = after;
/**
 * Defines a piece of code to run after each test in this file.
 * @see https://help.testim.io/docs/getting-started
 */
function afterEach(fn) { throw new StubError('afterEach'); }
exports.afterEach = afterEach;
/**
 * Skips the given test.
 * @see https://help.testim.io/docs/getting-started
 */
function skip(name, fn) { throw new StubError('skip'); }
exports.skip = skip;
/**
 * Runs only the current test or test suite in this file.
 * @see https://help.testim.io/docs/getting-started
 */
function only(name, fn) { throw new StubError('only'); }
exports.only = only;
/**
 * Skips the given suite.
 * @see https://help.testim.io/docs/getting-started
 */
function describeSkip(name, fn) { throw new StubError('describeSkip'); }
exports.describeSkip = describeSkip;
/**
 * Runs only given suite.
 * @see https://help.testim.io/docs/getting-started
 */
function describeOnly(name, fn) { throw new StubError('describeOnly'); }
exports.describeOnly = describeOnly;
it.skip = test.skip = skip;
it.only = test.only = only;
describe.skip = describeSkip;
describe.only = describeOnly;
/**
 * A SmartLocator is like a stable selector. It contains a ton of interesting metadata and it's one of the bits Testim's AI
 * runs reinforcement learning on. It selects each element in thousands of ways and runs a consensus algorithm on the results.
 * @see https://help.testim.io/docs/working-with-locators
 */
var Locator = /** @class */ (function () {
    function Locator() {
    }
    Locator.fromSelector = function (selector) {
        throw new StubError('Locator.fromSelector');
    };
    Locator.set = function (locators) { };
    Locator["for"] = function (locatorId) {
        throw new StubError('Locator.for');
    };
    /**
     * Sets the locator confidence threshold
     * @param threshold the locator conidence score
     */
    Locator.prototype.setConfidenceThreshold = function (threshold) {
        throw new StubError('setConfidenceThreshold');
    };
    return Locator;
}());
exports.Locator = Locator;
/**
 * Finds a Smart Locator by name
 * @see https://help.testim.io/docs/working-with-locators
 */
function l(locatorId) {
    return Locator["for"](locatorId);
}
exports.l = l;
/**
 * Create Locator from CSS selector
 * @see https://help.testim.io/docs/working-with-locators
 */
function fromSelector(selector) {
    return Locator.fromSelector(selector);
}
exports.fromSelector = fromSelector;
/**
 * Changes the tab or frame context
 * @see https://help.testim.io/docs/with-context
 */
function withContext(contextOptions) { throw new StubError('withContext'); }
exports.withContext = withContext;
